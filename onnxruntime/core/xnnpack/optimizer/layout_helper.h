// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#pragma once

#include <onnx/onnx_pb.h>

#include <vector>

#include "core/common/common.h"
#include "core/graph/graph.h"
#include "core/framework/op_node_proto_helper.h"

namespace onnxruntime {
namespace xnnpack {
Status CreateTransposeNode(::ONNX_NAMESPACE::NodeProto& node, const std::string& node_name,
                           const std::string& input_name, const std::string& output_name,
                           const std::vector<int64_t>& perm);

//It tries to generate a subgraph as a GraphProto to replace an existing node
class NodeProcessor {
 protected:
  const Node& node_;

 private:
  ProtoHelperNodeContext nc_;

 protected:
  OpNodeProtoHelper<ProtoHelperNodeContext> info_;
  // All node args owned by <*this> graph. Key is node arg name.
  std::unordered_set<std::string> node_args_names_;
  int name_generator_ = 0;
  const std::unordered_set<const NodeArg*>& graph_const_values_;
  std::string GenerateNodeArgName(const std::string& base_name) {
    std::string new_name = base_name;
    // Check if new_name has been used in as any of node_args_' names.
    // Check if new_name has been generated by this function.
    // If both are not, add new_name into name set and return the new_name
    // as the generated name. Otherwise, keep generating new names.
    while (node_args_names_.find(new_name) != node_args_names_.end()) {
      std::ostringstream str;
      str << base_name << "_token_" << name_generator_++;
      new_name = str.str();
    }

    node_args_names_.insert(new_name);
    return new_name;
  }

 public:
  NodeProcessor(const Node& node, const std::unordered_set<const NodeArg*>& graph_const_values)
      : node_(node), nc_(node_), info_(&nc_), graph_const_values_(graph_const_values) {
    std::unordered_set<std::string>& names = node_args_names_;
    node.ForEachDef(
        [&names](const NodeArg& arg, bool /* is_input*/) {
          if (!arg.Exists()) return;
          names.insert(arg.Name());
        },
        false);
  }
  virtual ~NodeProcessor() = default;
  virtual Status Generate(std::unique_ptr<::ONNX_NAMESPACE::GraphProto>& output_graph) = 0;
};
}  // namespace xnnpack
}  // namespace onnxruntime